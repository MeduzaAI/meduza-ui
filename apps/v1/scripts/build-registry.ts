import { exec } from "child_process"
import { promises as fs } from "fs"
import { writeFileSync, mkdirSync } from 'node:fs';
import { join } from 'node:path';
import path from "path"
import { rimraf } from "rimraf"

import { availableStyles } from '../registry/config/styles';
import { registry } from '../registry/index';
import { buildColorsRegistry } from './build-colors';

async function buildRegistryIndex() {
    let index = `/* eslint-disable @typescript-eslint/ban-ts-comment */
/* eslint-disable @typescript-eslint/no-explicit-any */
// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import * as Vue from "vue"

export const Index: Record<string, any> = {`

    for (const item of registry.items) {
        const resolveFiles = item.files?.map(
            (file) => `registry/default/${file.path}`
        )
        if (!resolveFiles) {
            continue
        }

        const componentPath = item.files?.[0]?.path
            ? `@@/registry/default/${item.files[0].path}`
            : ""

        index += `
  "${item.name}": {
    name: "${item.name}",
    description: "${item.description ?? ""}",
    type: "${item.type}",
    registryDependencies: ${JSON.stringify(item.registryDependencies || [])},
    files: [${item.files?.map((file) => {
            const filePath = `@@/registry/default/${typeof file === "string" ? file : file.path}`
            const resolvedFilePath = path.resolve(filePath)
            return typeof file === "string"
                ? `"${resolvedFilePath}"`
                : `{
      path: "${filePath}",
      type: "${file.type}",
      target: "${file.target ?? ""}"
    }`
        })}],
    component: ${componentPath
                ? `Vue.defineAsyncComponent(async () => {
      const mod = await import("${componentPath}")
      return mod.default || mod
    })`
                : "null"
            },
    category: ${JSON.stringify(item.category || "")},
  },`
    }

    index += `
}`

    console.log(`#Ô∏è‚É£  ${registry.items.length} items found`)

    // Write registry index.
    rimraf.sync(path.join(process.cwd(), "registry/__index__.ts"))
    await fs.writeFile(path.join(process.cwd(), "registry/__index__.ts"), index)
}

async function buildRegistryJsonFile() {
    // 1. Fix the path for registry items.
    const fixedRegistry = {
        ...registry,
        items: registry.items.map((item) => {
            const files = item.files?.map((file) => {
                // Remove leading slash if present and fix the path
                const cleanPath = file.path.startsWith('/') ? file.path.substring(1) : file.path
                // Add empty content - CLI will populate it
                return {
                    ...file,
                    path: `registry/default/${cleanPath}`,
                    content: "", // Add empty content for CLI validation
                }
            })

            return {
                ...item,
                files,
            }
        }),
    }

    // 2. Write the content of the registry to `registry.json`
    rimraf.sync(path.join(process.cwd(), `registry.json`))
    await fs.writeFile(
        path.join(process.cwd(), `registry.json`),
        JSON.stringify(fixedRegistry, null, 2)
    )
}

async function buildRegistry() {
    return new Promise((resolve, reject) => {
        const buildProcess = exec(
            `npx meduza-ui build registry.json --output ./public/r/styles/default --verbose`
        )

        buildProcess.on("exit", (code) => {
            if (code === 0) {
                resolve(undefined)
            } else {
                reject(new Error(`Process exited with code ${code}`))
            }
        })
    })
}

async function buildMain() {
    console.log('üèóÔ∏è  Building registry...');

    // Ensure output directory exists
    const outputDir = join(process.cwd(), 'public/r');
    mkdirSync(outputDir, { recursive: true });
    mkdirSync(join(outputDir, 'styles'), { recursive: true });
    mkdirSync(join(outputDir, 'styles/default'), { recursive: true });
    mkdirSync(join(outputDir, 'colors'), { recursive: true });

    // 1. Build styles index
    writeFileSync(
        join(outputDir, 'styles/index.json'),
        JSON.stringify(availableStyles, null, 2)
    );

    // 2. Build colors registry
    await buildColorsRegistry();

    try {
        console.log("üóÇÔ∏è Building registry/__index__.ts...")
        await buildRegistryIndex()

        console.log("üíÖ Building registry.json...")
        await buildRegistryJsonFile()

        console.log("üèóÔ∏è Building registry...")
        await buildRegistry()

        console.log('‚úÖ Registry built successfully!');
    } catch (error) {
        console.error(error)
        process.exit(1)
    }
}



// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
    buildMain().catch(console.error);
}
